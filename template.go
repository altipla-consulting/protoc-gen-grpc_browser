package main

import (
	"fmt"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	pbannotations "google.golang.org/genproto/googleapis/api/annotations"
)

type templateData struct {
	Version        string
	SourceFilename string
	Services       []*Service
}

func (data *templateData) Quote() string {
	return "`"
}

type Service struct {
	*descriptor.ServiceDescriptorProto
}

func (s *Service) Methods() []*Method {
	methods := []*Method{}
	for _, method := range s.GetMethod() {
		methods = append(methods, &Method{method})
	}

	return methods
}

type Method struct {
	*descriptor.MethodDescriptorProto
}

func (method *Method) HTTPMethod() string {
	if method.GetOptions() == nil {
		return ""
	}

	if !proto.HasExtension(method.Options, pbannotations.E_Http) {
		return ""
	}
	ext, err := proto.GetExtension(method.Options, pbannotations.E_Http)
	if err != nil {
		panic(err)
	}
	opts := ext.(*pbannotations.HttpRule)

	switch opts.GetPattern().(type) {
	case *pbannotations.HttpRule_Get:
		return "GET"
	case *pbannotations.HttpRule_Put:
		return "PUT"
	case *pbannotations.HttpRule_Post:
		return "POST"
	case *pbannotations.HttpRule_Delete:
		return "DELETE"
	}

	return ""
}

func (method *Method) httpPath() string {
	ext, err := proto.GetExtension(method.Options, pbannotations.E_Http)
	if err != nil {
		panic(err)
	}
	opts := ext.(*pbannotations.HttpRule)

	switch rule := opts.GetPattern().(type) {
	case *pbannotations.HttpRule_Get:
		return rule.Get
	case *pbannotations.HttpRule_Put:
		return rule.Put
	case *pbannotations.HttpRule_Post:
		return rule.Post
	case *pbannotations.HttpRule_Delete:
		return rule.Delete
	}

	panic("http rule has no path")
}

func (method *Method) Segments() ([]*Segment, error) {
	l := &lexer{
		input: method.httpPath(),
	}
	for state := lexSegment; state != nil; {
		state = state(l)
	}
	if l.err != nil {
		return nil, fmt.Errorf("cannot parse path: %v", l.err)
	}
	return l.segments, nil
}

func (method *Method) Binding() (string, error) {
	segments, err := method.Segments()
	if err != nil {
		return "", err
	}
	bindings := make([]string, len(segments))
	for i, seg := range segments {
		bindings[i] = seg.Binding
	}
	return "/" + strings.Join(bindings, "/"), nil
}

func (method *Method) HasBody() bool {
	ext, err := proto.GetExtension(method.Options, pbannotations.E_Http)
	if err != nil {
		panic(err)
	}
	opts := ext.(*pbannotations.HttpRule)

	return opts.Body == "*"
}

func (method *Method) UnsetKeys() (string, error) {
	segments, err := method.Segments()
	if err != nil {
		return "", err
	}
	var vars []string
	for _, seg := range segments {
		if seg.Name() != "" {
			vars = append(vars, "'"+seg.Name()+"'")
		}
	}
	return "[" + strings.Join(vars, ", ") + "]", nil
}

const browserTemplate = `// Code generated by protoc-gen-grpc_browser {{.Version}}, DO NOT EDIT.
// Source: {{.SourceFilename}}

const grpc = require('@altipla/grpc-browser');

{{range .Services}}
module.exports = class {{.GetName}}Client {
	constructor(opts = {}) {
		this._caller = new grpc.Caller(opts);
	}{{range .Methods}}{{if .HTTPMethod}}

	{{.GetName}}(req) {
		{{range .Segments -}}
		{{if .Parts -}}
		{
			let parts = {{$.Quote}}{{.Binding}}{{$.Quote}}.split('/');
			let fmt = {{$.Quote}}parameter req.{{.Name}} should have the format "{{.RawParts}}"{{$.Quote}};
			if (parts.length !== {{len .Parts}}) { throw new Error(fmt); }
			{{range $i, $part := .Parts -}}
			{{if not (eq . "*") -}}
			if (parts[{{$i}}] !== '{{.}}') { throw new Error(fmt); }
			{{- end -}}
			{{end}}
		}
		{{end -}}
		{{end -}}
		return this._caller.send('{{.HTTPMethod}}', {{$.Quote}}{{.Binding}}{{$.Quote}}, req, {{.HasBody}}, {{.UnsetKeys}});
	}{{end}}{{end}}
};
{{end}}
`
